# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pA8zg7zaabsI4-nn9ALcUJMRrvgC16uv
"""

# streamlit_app.py
import streamlit as st
import pandas as pd
from scipy.spatial.distance import pdist, squareform

# ---------------------------
# Load and preprocess data
# ---------------------------
@st.cache_data
def load_data():
    df = pd.read_csv("Cognify1.csv")
    df = df[['Restaurant ID','Restaurant Name','Cuisines','Price range','Aggregate rating','Votes']]
    df = df.dropna()

    # keep only rating >= 4
    df = df[df['Aggregate rating'] >= 4.0]

    # Clean cuisines
    df['Cuisines'] = df['Cuisines'].str.replace(r'\[|\]', '', regex=True)
    df['Cuisines'] = df['Cuisines'].str.split(', ')
    df = df.explode('Cuisines')

    # Create crosstab for similarity
    restoXcuisines = pd.crosstab(df['Restaurant Name'], df['Cuisines'])

    # Jaccard similarity
    jaccardDist = pdist(restoXcuisines.values, metric='jaccard')
    jaccardMatrix = squareform(jaccardDist)
    jaccardSim = 1 - jaccardMatrix
    dfJaccard = pd.DataFrame(
        jaccardSim,
        index=restoXcuisines.index,
        columns=restoXcuisines.index
    )
    return df, dfJaccard

df, dfJaccard = load_data()

# ---------------------------
# Streamlit UI
# ---------------------------
st.title("üçΩÔ∏è Restaurant Recommender System")

st.write("Select a restaurant, and we'll recommend similar restaurants based on cuisines and ratings.")

# Restaurant selection
restaurant = st.selectbox("Choose a restaurant:", sorted(df['Restaurant Name'].unique()))

if restaurant:
    sim = dfJaccard.loc[restaurant].sort_values(ascending=False)
    sim = pd.DataFrame({'Restaurant Name': sim.index, 'simScore': sim.values})
    sim = sim[(sim['Restaurant Name'] != restaurant) & (sim['simScore'] >= 0.7)].head(5)

    # Merge with ratings
    RestoRec = pd.merge(sim, df[['Restaurant Name', 'Aggregate rating']], on='Restaurant Name', how='inner')
    FinalRestoRec = RestoRec.sort_values('Aggregate rating', ascending=False).drop_duplicates('Restaurant Name', keep='first')

    if not FinalRestoRec.empty:
        st.subheader("Recommended Restaurants üç¥")
        st.dataframe(FinalRestoRec)
    else:
        st.warning("No strong recommendations found for this restaurant. Try another one!")